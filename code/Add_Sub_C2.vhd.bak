-- UNIVERSIDADE FEDERAL DO RIO DE JANEIRO - UFRJ
-- Autor: Christian Marques de Oliveira Silva
--	Disciplina: Laboratório de Sistemas Digitais
--
--	Objetivo: Desenvolvimento de uma Unidade Lógica e Aritmética (ULA) de 4 bits e 8 operações
--
--	Requisitos:
--	* Operação da ULA selecionada por 3 chaves externas;
--	* Operações obrigatórias: soma e subtração em complemento a 2;
--	* Dados de entrada gerados por um módulo auxiliar, “bancada de testes”, explicado mais
--	abaixo;
--	* Exibição dos dados de entrada e resultado, em caracteres hexadecimais, nos displays de 7
--	segmentos disponíveis na placa FPGA DE2-115, no laboratório LABSLAND.
--	* Saídas: operandos e resultados, exibidos nos displays de 7 segmentos. 4 flags: Zero, Negativo,
--	Carry out e Overflow exibidos nos LEDs disponíveis na placa FPGA DE2-115.
--
--	Funcionamento
--		As entradas da ULA são geradas por um módulo “bancada de testes”, um contador, parte
--	integrante do projeto. As duas entradas são mostradas, juntamente com o resultado, nos
--	displays de 7 segmentos disponíveis. Os LEDs são utilizados para mostrar as quatro “flags”. Os
--	operandos vão mudando, em ordem crescente, a cada 2 segundos.
-----------------------------------------------------------------------------------------------------

------------------------------------
-- Bibliotecas
------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
------------------------------------

------------------------------------
-- Entidade Principal
------------------------------------
entity ULA is 
port(
	A,B						:	in		std_logic_vector(3 downto 0);		-- Operandos de 4 bits
	SEL						:	in		std_logic_vector(2 downto 0);
	ZER,NEG,OVER			:	out	std_logic;
	COUT						:	inout	std_logic;
	RESULT					:	out	std_logic_vector(3 downto 0));	-- Resultado de 4 bits dos 2 operandos 
end ULA;
------------------------------------



------------------------------------
-- Entidade Principal
------------------------------------
architecture hardware of ULA is

component FA_4_bits is
port (
	x,y	:	in		std_logic_vector(3 downto 0);
	cin	:	in		std_logic;
	cout	:	out	std_logic;
	z		:	out	std_logic_vector(3 downto 0));
end component;

signal operatorA, operatorB, res, res_map	:	std_logic_vector(3 downto 0);
signal c_in	:	std_logic;

begin


	proc: process(A,B)
		variable signalA	: std_logic := A(3);
		variable signalB 	: std_logic := B(3);
		variable A_diff_B : std_logic := signalA xor signalB;
	begin
		
		-- Inicialização padrão das entradas	
		operatorA <= A;
		operatorB <= B;
		------------------------------------

		 -- Soma em complemento de 2
		if (SEL = "000") then
			c_in <= '0';
		
		-- Subtração em complemento de 2
		elsif (SEL = "111") then
			operatorB <= not B;
			c_in <= '1';
		end if;
		
		
	end process proc;
	
	adder: FA_4_bits port map(operatorA, operatorB, c_in, COUT, res_map);
	
	check_result: process(operatorA,operatorB)
		variable signalA	: std_logic := operatorA(3);
		variable signalB 	: std_logic := operatorB(3);
		variable A_diff_B : std_logic := signalA xor signalB;
	begin
	
		res <= res_map;
			
		-- Se os operadores possuem o mesmo sinal e a resposta tem um sinal diferente, houve overflow
		if ((A_diff_B = '0') and (res(3) /= signalA)) then
			OVER <= '1';
			ZER <= '0';
			NEG <= '0';
		
		else -- Não houve overflow
			OVER <= '0';
			
			-- Flag de resultado negativo
			if (res(3) = '1') then NEG <= '1'; else NEG <= '0'; end if;
			
			-- Flag de resultado zero
			if (res = "0000") then ZER <= '1'; else ZER <= '0'; end if;
		end if;
		
	
	end process check_result;
	
	RESULT <= res;

end hardware;
------------------------------------










